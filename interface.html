<!doctype html>
<html lang="en">
<!-- TODO clean up the MVC-arity of this -->
<!-- TODO proper UI design (aka organize the divs better)-->
<!-- TODO make it look pretty (some css) -->
<head>
    <title>SiPoPaMa</title>
    <meta charset="UTF-8">
    <script src="angular.min.js"></script>
    <script src="sjcl.js"></script>
    <script src="scrypt.js"></script>
    <script src="FileSaver.min.js"></script>
</head>

<body ng-app="myApp" ng-controller="myCtrl">
<div>
    <label>Passphrase:</label>
    <input ng-model="myPW" placeholder="Put in passphrase" type="password">
    <!--  for debug only <div>KDF is {{dispKDF}}</div> -->
    <div>Password is {{toPass}}</div>
</div>
<div>
    Add a new one:
    <label>Label:</label>
    <input ng-model="label" placeholder="Site label" type="text">
    <label>KDF type:</label>
    <select name="kdfsel" ng-model="kdfselect">
        <option value="pbkdf2">PBKDF2</option>
        <option value="scrypt">scrypt</option>
        <!-- Add in customization of kdf? -->
        <!-- TODO: bcrypt -->
        <!-- TODO: figure out how to change defaults when selectbox changes -->
        <!-- TODO: figure out how to change visible options when selectbox
             changes -->
        <!-- TODO: dont hardcode all of the scrypt params -->
    </select>
    <label>Password type</label>
    <select name="pwsel" ng-model="pwselect">
        <option value="nb64">NB64</option>
        <option value="nhex">NHEX</option>
        <option value="dw">DiceWare (exp)</option>
        <!-- TODO: add ndiceware or diceware with a spec.
             ala "w W w" == word Capword word, or "www" == wordanotherthird
             maybe l for letter, n for number, s for symbol, ' ' for space, etc
           -->
    </select>
    <div>
        <label>PW Length:</label><input ng-model="pwlen" type="text">
    </div>
    <div>
        <label>Rounds:</label><input ng-model="pbkdf2n" type="text">
        <label>ProvidedSalt:</label><input ng-model="pbkdfsalt" type="text">
    </div>
    <button ng-click="genKDF(kdfselect, pwselect, pbkdfsalt, pbkdf2n)">Gimmie</button>
    <button ng-click="saveIT(kdfselect, pwselect, pbkdfsalt, pbkdf2n)">Save It!</button>
</div>
<div>
    You are making one for {{label}} of type {{kdfselect}}<br>
    {{derivedKDFSpec}} {{derivedtopass}} <br>
    Proposed Password is {{proposedPass}}
</div>
<div>
    <table>
        <tr ng-repeat="(key, value) in logins">
            <td>{{ key }}</td>
            <td>{{ value.kdf }}</td>
            <td>{{ value.topass}}</td>
            <td>
                <button ng-click="dokdf(value.kdf, value.topass)">GetKDF</button>
            </td>
        </tr>
    </table>
</div>

<div>
    <!-- TODO allow export to html5 localstorage -->
    <!-- TODO allow export via postback to specificed URL (and import
     from same) -->
    <input ng-model="targetFile" type="text">
    <button ng-click="filesave(targetFile)">File Save</button>
    Or, copy paste:
    <div>
        {{exportForm}}
    </div>
</div>
<script>
    var myScript;
    var dicelist = [];

    function doPBKDF2(kdfspec, pw) {
        var spec = kdfspec.split(":");
        //spec is pbkdf2:rounds:salt
        return sjcl.misc.pbkdf2(sjcl.codec.utf8String.toBits(pw),
            sjcl.codec.utf8String.toBits(spec[2]),
            spec[1], 32 * 8);
    }

    function doScrypt(kdfspec, pw) {
        var spec = kdfspec.split(":");
        //spec is scrypt:salt:r:N:p
        //note that for javascript, increasing p is best bet since memory is
        //constrained.
        return myScript.crypto_scrypt(myScript.encode_utf8(pw),
            myScript.encode_utf8(spec[1]),
            spec[2], spec[3], spec[4], 64);
    }

    function dohexN(passspec, kdfed) {
        var spec = passspec.split(":");
        var numChars = parseInt(spec[1]);
        var hexed = sjcl.codec.hex.fromBits(kdfed);
        return hexed.substring(0, numChars);
    }

    function doB64N(passspec, kdfed) {
        var spec = passspec.split(":");
        var numChars = parseInt(spec[1]);
        var b64ed = sjcl.codec.base64.fromBits(kdfed, true, true);
        return b64ed.substring(0, numChars);
    }

    function doDW(passspec, kdfed) {
        var res = "";
        var off = 0;
        for (i = 0; i < 4; i++) {
            var rnd = sjcl.bitArray.extract(kdfed, off, 13);
            off += 13;
            if (rnd > 6 * 6 * 6 * 6 * 6) {
                //worry about running out of bits later....
                i--;
                continue;
            }
            if (dicelist.length !== 7776)
                return "This is bad the list is the wrong length";
            var word = dicelist[rnd % dicelist.length];
            if (i == 0)
                res = word;
            else
                res = res.concat("_", word);
        }
        return res;
    }

    function defps(passspec) {
        var spec = passspec.split(":");
        if (spec[0] == "nb64" || spec[0] == "nhex") {
            if (isNaN(spec[1]))
                return spec[0] + ":20";
            else
                return passspec;
        }
        if (spec[0] == "dw") {
            if (isNaN(spec[1]))
                return "dw:4";
            else
                return passspec;
        }
    }

    function passfromspec(passspec, inkdf) {
        var spec = passspec.split(":");
        if (spec[0] == "nb64") {
            return doB64N(passspec, inkdf);
        } else if (spec[0] == "nhex") {
            return dohexN(passspec, inkdf);
        } else if (spec[0] == "dw") {
            return doDW(passspec, inkdf)
        } else {
            return "some sort of bug or something; this is bad";
        }
    }

    function kdffromspec(kdfspec, inpw) {
        var spec = kdfspec.split(":");
        if (spec[0] == "pbkdf2") {
            return doPBKDF2(kdfspec, inpw);
        } else if (spec[0] == "scrypt") {
            //We round trip via hex to get into the sjcl format.
            return sjcl.codec.hex.toBits(myScript.to_hex
            (doScrypt(kdfspec, inpw)));
        } else {
            return inpw + kdfspec;
        }
    }

    var app = angular.module('myApp', []);
    app.controller('myCtrl', function ($scope, $http) {
        sjcl.random.startCollectors();


        $scope.genKDF = function (kdfsel, pwsel, thsalt, n) {
            var salt = thsalt;
            var mhm = new sjcl.misc.hmac(sjcl.codec.utf8String.toBits(thsalt), sjcl.hash.sha256);
            salt = sjcl.codec.base64.fromBits(mhm.encrypt(sjcl.random.randomWords(8, 1)), true, true);
            if (kdfsel == "pbkdf2") {
                $scope.derivedKDFSpec = kdfsel + ":" + n + ":" + salt;
            } else if (kdfsel == "scrypt") {
                $scope.derivedKDFSpec = kdfsel + ":" + salt + ":16384:8:" + n;
            }
            var derivedKDF = kdffromspec($scope.derivedKDFSpec, $scope.myPW);
            $scope.derivedtopass = defps(pwsel + ":" + $scope.pwlen);
            $scope.proposedPass = passfromspec($scope.derivedtopass, derivedKDF);
        }
        $scope.saveIT = function (kdfsel, pwsel, salt, n) {
            $scope.logins[$scope.label] = {"kdf": $scope.derivedKDFSpec, "topass": $scope.derivedtopass};
            $scope.exportForm = JSON.stringify($scope.logins);
        }
        $scope.dokdf = function (kdfspec, passspec) {
            var derivedKDF = kdffromspec(kdfspec, $scope.myPW);
            $scope.dispKDF = sjcl.codec.hex.fromBits(derivedKDF);
            $scope.toPass = passfromspec(passspec, derivedKDF);
        }
        $scope.filesave = function (filename) {
            var blob = new Blob([$scope.exportForm], {type: "text/plain;charset=utf-8"});
            saveAs(blob, filename);
        }
        $scope.compKDF = "not yet computed";
        //use 32MB
        scrypt_module_factory(on_ready, {requested_total_memory: 32 * 1048576});
        $scope.pwlen = "default";
        $scope.kdfselect = "scrypt";
        $scope.pwselect = "nb64";
        $scope.pbkdf2n = 3;
        $http({method: 'GET', url: "./saved.json", responseType: "json"})
            .success(function (response) {
                if (response == null)
                    response = {};
                $scope.logins = response;
                $scope.exportForm = response;
            });
        $http({method: 'GET', url: "./diceware.asc", responseType: "text"})
            .success(function (response) {
                dicelist = response.split("\n");
                for (var i = 0; i < dicelist.length; i++) {
                    dicelist[i] = dicelist[i].split('\t')[1];
                }
            });
        $scope.targetFile = "export.json";
    });

    function on_ready(scrypt) {
        myScript = scrypt;
    }
</script>
</body>

</html>
